#!/bin/bash
# sear2k - A tool for finding short sequences in genomes using ssearch36
# Author: Sergei Kosushkin
# Version: 0.2 + bitscore + -b/--best + flank50(best) + -m/--minus + -s/--stop + fixed best headers + dedup best loci
# License: MIT
#
# Usage:
# sear2k [-b|--best [N]] [-m|--minus] [-s|--stop [N]] <query.fasta> <bank.fasta> \
#        [sequence_length_fraction=0.9] [similarity_threshold=65] [flank_size=50] [keep_2k_splits=0]
#
# Options:
#   -b, --best [N]   Take top N UNIQUE hits by bitscore (default 100), extract with .50bp flanks, align with MAFFT
#   -m, --minus      Skip minus-bank depletion rounds (single round per split bank)
#   -s, --stop [N]   Stop searching once >=N hits are collected (default 1000)
#
# Dependencies: ssearch36, bedtools, seqkit, samtools (mafft if -b/--best)

usage() {
  echo "Usage: sear2k [-b|--best [N]] [-m|--minus] [-s|--stop [N]] <query.fasta> <bank.fasta> [Slf=0.9] [Homology=65] [Flank=50] [KeepSplits=0]"
}

if [[ $# -eq 0 ]]; then
  echo "No arguments supplied!"
  usage
  exit 1
fi

# -----------------------------
# parse options
# -----------------------------
BEST=0
BEST_N=100
SKIP_MINUS=0
STOP_EARLY=0
STOP_N=1000

args=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    --best|-b)
      BEST=1
      if [[ $# -ge 2 && "$2" =~ ^[0-9]+$ ]]; then
        BEST_N="$2"
        shift 2
      else
        shift 1
      fi
      ;;
    -b[0-9]*)
      BEST=1
      BEST_N="${1#-b}"
      shift 1
      ;;
    --minus|-m)
      SKIP_MINUS=1
      shift 1
      ;;
    --stop|-s)
      STOP_EARLY=1
      if [[ $# -ge 2 && "$2" =~ ^[0-9]+$ ]]; then
        STOP_N="$2"
        shift 2
      else
        shift 1
      fi
      ;;
    -s[0-9]*)
      STOP_EARLY=1
      STOP_N="${1#-s}"
      shift 1
      ;;
    --)
      shift
      args+=("$@")
      break
      ;;
    *)
      args+=("$1")
      shift
      ;;
  esac
done
set -- "${args[@]}"

# After parsing, first two args must be query and bank (and must not be flags)
if [[ $# -lt 2 || "$1" == -* || "$2" == -* ]]; then
  usage
  exit 1
fi

query_in="$1"
bank_in="$2"

# Validate input files explicitly
if [[ ! -f "$query_in" ]]; then
  echo "File $query_in: not found"
  exit 1
fi
if [[ ! -f "$bank_in" ]]; then
  echo "File $bank_in: not found"
  exit 1
fi

# Verify required programs are available
need_bins=(ssearch36 bedtools seqkit samtools)
if [[ $BEST -eq 1 ]]; then
  need_bins+=(mafft)
fi
for b in "${need_bins[@]}"; do
  if ! command -v "$b" >/dev/null 2>&1; then
    echo "Program $b: not found in PATH"
    exit 1
  fi
done

ORIGINAL_BANK="$bank_in"
WORKING_BANK="$bank_in"
TEMP_BANK_CREATED=0

# Check/create fai
if [[ -f "$ORIGINAL_BANK".fai ]]; then
  echo "fai index found"
else
  echo "Creating fai index..."
  samtools faidx "$ORIGINAL_BANK"
fi

# Underscore workaround
underscores=$(awk '/_/' "$ORIGINAL_BANK".fai)
if [[ $underscores != "" ]]; then
  echo "WARNING: Bank file contains underscores in sequence names"
  echo "Creating temporary copy with placeholder substitution..."

  TEMP_BANK="${ORIGINAL_BANK%.*}_temp_clean.${ORIGINAL_BANK##*.}"
  awk '{gsub(/_/,"@UNDERSCORE@")}1' "$ORIGINAL_BANK" > "$TEMP_BANK"
  samtools faidx "$TEMP_BANK"

  WORKING_BANK="$TEMP_BANK"
  TEMP_BANK_CREATED=1
  echo "Using temporary cleaned bank: $WORKING_BANK"
else
  echo "No underscores detected - using original bank file"
fi

# Defaults
Slf=${3:-0.9}
Homology=${4:-65}
FlankSize=${5:-50}
KeepSplits=${6:-0}

# Query length / overlap length
len=$(awk '/^>/{if (l!="") print l; l=0; next}{l+=length($0)}END{print l}' "$query_in")
flen=$(awk -v a=$Slf -v b=$len 'BEGIN{print int(a*b)}')
echo "Query length = $len bp, overlap = $flen bp"

# Split bank if needed
split=$(ls 2>/dev/null | grep "$WORKING_BANK".part_* | grep .2k.part_ | wc -l)
if [[ $split != "0" ]]; then
  echo "skipping 2k split"
else
  seqkit sliding -g -s 2000 -W 2500 "$WORKING_BANK" > "$WORKING_BANK"."2k.bnk"
  seqkit split2 -p 20 -O . "$WORKING_BANK"."2k.bnk"
fi

query="$query_in"
qname="${query%.*}"
taxname=$(echo "$WORKING_BANK" | cut -c 1-3)

: > "$WORKING_BANK".all_hits.txt

HIT_COUNT=0
STOP_NOW=0

# Search
for bank in *.2k.part_*.bnk; do
  [[ "$bank" == minus_* ]] && continue
  [[ "$bank" == *.fai ]] && continue
  [[ "$bank" == *_s.fai ]] && continue

  echo "searching $query in $bank"
  taxname=$(echo "$bank" | cut -c 1-3)

  round=1
  Pl=1

  while [[ $Pl != "0" ]]; do
    echo "round $round"
    echo "$query $bank"

    ssearch36 -g -3 -T 24 -Q -n -z 11 -E 2 -w 95 -W 70 -m 8C "$query" "$bank" 3 \
    | awk '/^[^#]/ {
        printf($2"\t"$9-1"\t"$10"\t"$10-$9+1"\t");
        if ($8-$7>0) print $8-$7+1"\t+\t"$3"\t"$12;
        else print -($8-$7+1)"\t-\t"$3"\t"$12
      }' \
    | sort -V \
    | bedtools merge -s -c 4,5,6,7,8 -o max,max,distinct,max,max \
    | awk '{if ($7>='"$Homology"' && $4>='"$flen"') print}' \
    | sort -V > plus_to_add_"$round"_"$bank".bed

    Pl=$(wc -l < plus_to_add_"$round"_"$bank".bed)
    echo "$Pl hits"

    cat plus_to_add_"$round"_"$bank".bed >> "$WORKING_BANK".all_hits.txt

    HIT_COUNT=$((HIT_COUNT + Pl))
    if [[ $STOP_EARLY -eq 1 && $HIT_COUNT -ge $STOP_N ]]; then
      echo "[STOP] Reached $HIT_COUNT hits (limit $STOP_N). Stopping further searches."
      STOP_NOW=1
      break
    fi

    samtools faidx "$bank"
    sort -V "$bank".fai > "${bank}_s.fai"

    if [[ "$Pl" == "0" ]]; then
      round=$((round+1))
      break
    fi

    if [[ $SKIP_MINUS -eq 1 ]]; then
      break
    fi

    echo "creating minus bank"
    cat plus_to_add_*_"$bank".bed | sort -V > "$round"_"$bank".bed

    bedtools complement -i "$round"_"$bank".bed -g "${bank}_s.fai" \
      | bedtools sort -i \
      | bedtools getfasta -s -fi "$bank" -bed - \
      | awk '/^>/ && a!=1 {gsub(/[":"]/, "_")}{gsub(/["()"]/,"");a=1};a=0;1' > minus_"$round"_"$bank"

    bank=$(echo "minus_${round}_${bank}")
    round=$((round+1))
    echo "$bank $round"
  done

  if [[ $STOP_NOW -eq 1 ]]; then
    break
  fi
done

# Offsets (unchanged)
cat "$WORKING_BANK".all_hits.txt |
  awk '{sub(/_sliding:/," ")}{sub(/_sliding_/," ")}{print $2}' |
  awk '{gsub(/_/," ")}{print}' |
  awk '{gsub(/-/," -")}1' |
  awk '{sum=0;for(i=1;i<=NF;i++)if($i>0)sum+=$i}{print sum}' > "$WORKING_BANK".all

# FINAL BED (bitscore in col7)
paste "$WORKING_BANK".all_hits.txt "$WORKING_BANK".all \
| awk 'BEGIN{OFS="\t"} {print $0, $2+$NF, $3+$NF}' \
| awk 'BEGIN{OFS="\t"}
       {
         chrom=$1
         sub(/_sliding:.*/, "", chrom)
         sub(/_sliding_.*/, "", chrom)
         print chrom, $(NF-1), $NF, $7, $5, $6, $8
       }' \
| bedtools sort -i - \
| bedtools slop -l 1 -r -1 -i - -g "$WORKING_BANK".fai \
| bedtools merge -s -i - -c 4,5,6,7 -o max,max,distinct,max \
> "$taxname-$qname.bed"

# BEST: top N UNIQUE loci by bitscore + .50 flanks + MAFFT
# FIXED:
#  - de-duplicate by (chrom,start,end,strand) after sorting by bitscore
#  - no double coords (use -nameOnly)
#  - no double strand (do NOT include strand in name)
if [[ $BEST -eq 1 ]]; then
  echo "Creating best hits (top $BEST_N UNIQUE hits by bitscore) + 50bp flanks + MAFFT..."

  paste "$WORKING_BANK".all_hits.txt "$WORKING_BANK".all \
  | awk 'BEGIN{OFS="\t"}
         {
           off=$NF
           chrom=$1
           sub(/_sliding:.*/, "", chrom)
           sub(/_sliding_.*/, "", chrom)
           print chrom, $2+off, $3+off, $7, $5, $6, $8
         }' \
  | sort -k7,7nr \
  | awk 'BEGIN{OFS="\t"}{key=$1"\t"$2"\t"$3"\t"$6; if(!seen[key]++){print}}' \
  | head -n "$BEST_N" \
  > "$taxname-$qname.best${BEST_N}.bed7"

  # BED6 for slop/getfasta: chrom start end name score strand
  awk 'BEGIN{OFS="\t"} {print $1,$2,$3,"tmp",$7,$6}' \
    "$taxname-$qname.best${BEST_N}.bed7" \
  > "$taxname-$qname.best${BEST_N}.bed"

  bedtools slop -s -g "$WORKING_BANK".fai -b 50 -i "$taxname-$qname.best${BEST_N}.bed" \
  > "$taxname-$qname.best${BEST_N}.flank50.tmp.bed"

  # do NOT embed strand in name; bedtools getfasta -s appends it once
  awk 'BEGIN{OFS="\t"} {name=$1":"$2"-"$3; print $1,$2,$3,name,$5,$6}' \
    "$taxname-$qname.best${BEST_N}.flank50.tmp.bed" \
  > "$taxname-$qname.best${BEST_N}.flank50.bed"

  # extra safety: dedupe after slop (rare but possible)
  sort -k1,1 -k2,2n -k3,3n -k6,6 "$taxname-$qname.best${BEST_N}.flank50.bed" \
  | awk 'BEGIN{OFS="\t"}{key=$1"\t"$2"\t"$3"\t"$6; if(!seen[key]++){print}}' \
  > "$taxname-$qname.best${BEST_N}.flank50.uniq.bed"

  bedtools getfasta -s -nameOnly -fi "$WORKING_BANK" -bed "$taxname-$qname.best${BEST_N}.flank50.uniq.bed" \
  > "$taxname-$qname.best${BEST_N}.fa"

  cat "$query" "$taxname-$qname.best${BEST_N}.fa" \
  | mafft --thread "$(nproc)" --threadtb "$(nproc)" --threadit "$(nproc)" \
          --localpair --maxiterate 1000 --ep 0.123 --nuc --reorder --quiet - \
  > "$taxname-$qname.best${BEST_N}.mafft.fa"

  rm -f "$taxname-$qname.best${BEST_N}.bed7" "$taxname-$qname.best${BEST_N}.flank50.tmp.bed"
  echo "MAFFT alignment: $taxname-$qname.best${BEST_N}.mafft.fa"
fi

# FINAL EXTRACTION
echo "Extracting sequences"
rm -f *2k.part* "$WORKING_BANK".all "$WORKING_BANK".all_hits.txt "$WORKING_BANK"."2k.bnk"

bname="$WORKING_BANK"
bedtools slop -s -i "$taxname-$qname.bed" -g "$bname.fai" -l "$FlankSize" -r "$FlankSize" > "$taxname.bed"
bedtools getfasta -s -fi "$bname" -bed "$taxname.bed" > "$taxname-$qname.bnk"
rm -f "$taxname.bed"

# Restore underscores if temp bank used
if [[ $TEMP_BANK_CREATED -eq 1 ]]; then
  echo "Restoring original sequence names in output files..."

  awk '{gsub(/@UNDERSCORE@/,"_")}1' "$taxname-$qname.bed" > "${taxname}-${qname}.bed.tmp"
  mv "${taxname}-${qname}.bed.tmp" "$taxname-$qname.bed"

  awk '{gsub(/@UNDERSCORE@/,"_")}1' "$taxname-$qname.bnk" > "${taxname}-${qname}.bnk.tmp"
  mv "${taxname}-${qname}.bnk.tmp" "$taxname-$qname.bnk"

  if [[ $BEST -eq 1 ]]; then
    awk '{gsub(/@UNDERSCORE@/,"_")}1' "$taxname-$qname.best${BEST_N}.bed" > "${taxname}-${qname}.best${BEST_N}.bed.tmp"
    mv "${taxname}-${qname}.best${BEST_N}.bed.tmp" "$taxname-$qname.best${BEST_N}.bed"

    awk '{gsub(/@UNDERSCORE@/,"_")}1' "$taxname-$qname.best${BEST_N}.flank50.bed" > "${taxname}-${qname}.best${BEST_N}.flank50.bed.tmp"
    mv "${taxname}-${qname}.best${BEST_N}.flank50.bed.tmp" "$taxname-$qname.best${BEST_N}.flank50.bed"

    awk '{gsub(/@UNDERSCORE@/,"_")}1' "$taxname-$qname.best${BEST_N}.flank50.uniq.bed" > "${taxname}-${qname}.best${BEST_N}.flank50.uniq.bed.tmp"
    mv "${taxname}-${qname}.best${BEST_N}.flank50.uniq.bed.tmp" "$taxname-$qname.best${BEST_N}.flank50.uniq.bed"

    awk '{gsub(/@UNDERSCORE@/,"_")}1' "$taxname-$qname.best${BEST_N}.fa" > "${taxname}-${qname}.best${BEST_N}.fa.tmp"
    mv "${taxname}-${qname}.best${BEST_N}.fa.tmp" "$taxname-$qname.best${BEST_N}.fa"

    awk '{gsub(/@UNDERSCORE@/,"_")}1' "$taxname-$qname.best${BEST_N}.mafft.fa" > "${taxname}-${qname}.best${BEST_N}.mafft.fa.tmp"
    mv "${taxname}-${qname}.best${BEST_N}.mafft.fa.tmp" "$taxname-$qname.best${BEST_N}.mafft.fa"
  fi
fi

rm -f *2k.bnk.fai *_s.fai 2>/dev/null || true

if [[ $KeepSplits -eq 0 ]]; then
  rm -f *2k.bnk *2k.bnk.fai *_s.fai
  echo "Temporary split files removed"
else
  echo "Temporary split files kept for re-use"
fi

if [[ $TEMP_BANK_CREATED -eq 1 ]]; then
  echo "Removing temporary cleaned bank file..."
  rm -f "$TEMP_BANK" "$TEMP_BANK".fai
  echo "Cleanup complete"
fi

Result=$(wc -l "$taxname-$qname.bed")
echo "Found $Result hits"
